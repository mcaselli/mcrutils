---
output: github_document
---

<!-- README.md is generated from README.Rmd. Please edit that file -->

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.path = "man/figures/README-",
  out.width = "100%"
)
```

# mcrutils

<!-- badges: start -->
[![Codecov test coverage](https://codecov.io/gh/mcaselli/mcrutils/graph/badge.svg)](https://app.codecov.io/gh/mcaselli/mcrutils)
[![R-CMD-check](https://github.com/mcaselli/mcrutils/actions/workflows/R-CMD-check.yaml/badge.svg)](https://github.com/mcaselli/mcrutils/actions/workflows/R-CMD-check.yaml)
<!-- badges: end -->

The goal of mcrutils is to provide a grab-bag of utility functions that
I find useful in my own R projects for data cleaning, analysis, and
reporting, including creating and visualizing year-to-date and quarterly
analyses, and customer account status/churn analysis.

## Installation

You can install the development version of mcrutils from
[GitHub](https://github.com/) with:

``` r
# install.packages("pak")
pak::pak("mcaselli/mcrutils")
```

## Examples

### Data cleaning

For data frames or tibbles that have character or factor columns storing
logical data, as may happen when reading from a database, CSV, or Excel
file, use `normalize_logicals()` to find and convert these columns to
logical type. This is a nice one-liner in a `dplyr` pipe

```{r example}
library(mcrutils)
library(dplyr, warn.conflicts = FALSE)

ugly_data <- tibble(
  logical_char = c("T", "F", "T"),
  logical_factor = factor(c("TRUE", "FALSE", "TRUE")),
  non_logical_char = c("a", "b", "c"),
  non_logical_factor = factor(c("x", "y", "z")),
  mixed_char = c("T", "F", "a"),
  mixed_factor = factor(c("TRUE", "FALSE", "x")),
  numeric_col = c(1.1, 2.2, 3.3)
)


ugly_data |> normalize_logicals()
```


### Customer account status/churn

`accounts_by_status()` takes order data (account IDs and order dates) and
categorizes accounts into different statuses (new, returning,
temporarily lost, regained, terminally lost) based on their
order behavior in each time interval (months, weeks, quarters, etc are supported). 

It also produces a running list of cumulative accounts. This function is useful
for understanding customer retention and churn. (counts of accounts in each
status category can be included as well; set `with_counts = TRUE`).


```{r accounts_by_status_example}
set.seed(1234)
n <- 25
dates <- seq(as.Date("2022-01-01"), as.Date("2022-06-30"), by = "day")
orders <- data.frame(
  account_id = sample(letters[1:10], n, replace = TRUE),
  order_date = sample(dates, n, replace = TRUE)
)

orders |> accounts_by_status(account_id, order_date)
```

`plot_accounts_by_status()` creates a line plot of the count of each account
status over time.

```{r plot_accounts_by_status}
orders |>
  plot_accounts_by_status(account_id, order_date)
```


### Business days 

`periodic_bizdays()` calculates the number of business days in each periodic
interval (e.g., monthly, quarterly) between two dates, using calendars from
`QuantLib` (see R package `qlcal`) for holiday definitions.

```{r periodic_bizdays_example}
periodic_bizdays(
  from = "2025-01-01",
  to = "2025-12-31",
  by = "quarter",
  quantlib_calendars = c("UnitedStates", "UnitedKingdom")
)
```

This is handy when analyzing data summarized by month or quarter and you want to
adjust for business days in each period.

`bizday_of_period()` calculates the business day of the period (month, quarter,
or year) for a given date and calendar.

```{r}
bizday_of_period(as.Date("2025-06-17"), "UnitedStates", period = "month")
bizday_of_period(as.Date("2025-06-17"), "UnitedStates", period = "year")
```

This is useful for creating a cumulative "burn-up" chart tracking mid-period
progress against e.g. the prior year (See vignette("mcrutils") for an example).

### Year-to-date helpers

`mcrutils` provides a handful functions that can be helpful in creating
year-to-date analyses

Below we have 2.5 years of historical sales data ending on June 1, 2025.


```{r}
set.seed(123)
sales <- tibble(
  date = seq(
    from = as.Date("2023-01-01"),
    to = as.Date("2025-06-01"),
    by = "month"
  ),
  amount = rpois(30, lambda = 100)
)

head(sales)

```

`ytd_bounds()` gets the start and end of the year-to-date period for the latest
year in a vector of dates, 

```{r}
(bounds <- ytd_bounds(sales$date))
```

and `is_ytd_comparable()` is a logical vector that
indicates whether the dates in a vector are within a year-to-date period
relative to a given `end_date`.

So we can quickly filter the historical data to see how we're doing in
2025 compared to the same period (i.e. January - June) in 2023 and 2024:

```{r}
sales |>
  filter(is_ytd_comparable(date, max(bounds))) |>
  group_by(year = lubridate::year(date)) |>
  summarise(ytd_sales = sum(amount))
```

### one-line datatables

`auto_dt()` is a one-line function that creates a `DT::datatable` object
from a data frame or tibble. It includes buttons to copy or download the data, 
filter tools, and no rownames. It applies percent, currency, and round
formatting to numeric columns, guessing the correct format from the data
type and column names. See `vignette("mcrutils")` for more examples, including how to specify the
set of strings that flag a column as percentage or currency.


```{r auto_dt_example, eval=FALSE}
tribble(
  ~product, ~weight, ~revenue, ~growth_pct,
  "Widget A", 13.53, 1023.21, 0.051,
  "Widget B", 22.61, 150.24, 0.103,
  "Widget C", 40.54, 502.26, 0.021,
  "Widget D", 34.21, 2000.95, 0.154
) |>
  mutate(product = as.factor(product)) |>
  auto_dt(numeric_digits = 1, pct_digits = 0)
```

![auto_dt() output](\man\figures\README-manual_screenshot_auto_dt.png)


### Quarterly breaks and labels

`scales::label_date_short()` is a great function for labeling dates in
`ggplot2`, but unfortunately it can't support quarterly breaks and
labels out of the box.

`label_quarters_short()` generates similar labels for quarterly date
breaks, labeling every quarter, but only including the year when it
changes from the previous label. `breaks_quarters()` generates quarterly
breaks for date scales.

```{r automatic-quarterly-breaks}
library(ggplot2)

economics |>
  filter(date >= "2005-05-01", date <= "2007-03-01") |>
  ggplot(aes(date, pce)) +
  geom_line() +
  scale_x_date(
    breaks = breaks_quarters(),
    labels = label_quarters_short()
  )
```

By default, `breaks_quarters()` tries to return a reasonable number of
breaks over a wide range of dates, down-sampling to semesters and years
as needed. See `vignette("mcrutils")` for more examples.
