---
title: "mcrutils"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{mcrutils}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r setup}
library(mcrutils)
```


# Introduction

The goal of `mcrutils` is to provide a grab-bag of utility functions that
I find useful in my own R projects for data cleaning, analysis, and
reporting, including creating and visualizing year-to-date and quarterly
analyses, and customer account status/churn analysis.


# Cleaning 

## Normalize logical columns

For data frames or tibbles that have character or factor columns storing 
logical data, as may happen when reading from a database, CSV, or Excel file,
use `normalize_logicals()` to find and convert these columns to logical type.
This is a nice one-liner in a `dplyr` pipe

```{r example}
library(dplyr, warn.conflicts = FALSE)
ugly_data <- tibble(
  logical_char = c("T", "F", "T"),
  logical_factor = factor(c("TRUE", "FALSE", "TRUE")),
  non_logical_char = c("a", "b", "c"),
  non_logical_factor = factor(c("x", "y", "z")),
  mixed_char = c("T", "F", "a"),
  mixed_factor = factor(c("TRUE", "FALSE", "x")),
  numeric_col = c(1.1, 2.2, 3.3)
)

ugly_data
```


```{r}
df <- ugly_data |> normalize_logicals()
df
```



# Analysis


## Customer account status, churn, and retention

`accounts_by_status()` categorizes accounts into statuses based on their order
activity (active, new, returning, temporarily lost, regained and terminally
lost) in each time interval (monthly, weekly, quarterly, etc. are supported).
It also produces  a running list of cumulative accounts. This is useful for
understanding customer retention and churn.

The `data.frame` returned by `accounts_by_status()` quickly gets unwieldy to
print, so to see how it works, let's make a small example data set with a list
of 25 orders from 10 accounts over 6 months.

```{r}
set.seed(1234)
n <- 25
dates <- seq(as.Date("2022-01-01"), as.Date("2022-06-30"), by = "day")
orders <- data.frame(
  account_id = sample(letters[1:10], n, replace = TRUE),
  order_date = sample(dates, n, replace = TRUE)
) |> arrange(order_date)

orders |> glimpse()
```

`accounts_by_status()` splits the order data by time periods, and returns the
accounts in each status category for each period as a list-column.

```{r}
orders |> accounts_by_status(account_id, order_date, by = "month")
```

If you want the count of accounts in each status category, set `with_counts =
TRUE` (the lists of account_ids are still included, we just omit them from the
printed output here).


```{r}
orders |>
  accounts_by_status(account_id, order_date, by = "month", with_counts = TRUE) |>
  select(period_start, starts_with("n_"))
```

Visualizing the count of accounts in each status over time can be helpful to
understand how the business is doing in terms of customer retention and churn.

`mcrutils` includes a larger example dataset `example_sales` with about 5000
orders between accounts over in the 2022--2024 time period.

```{r}
example_sales |> glimpse()
```

`accounts_by_status()` produces six status counts, plus one cumulative count--
that's up to seven data series to plot, so we need to be thoughtful about design
choices.

Showing the lost accounts as a negative value helps de-clutter the picture and
helps perception by encoding values above the axis as "good" and below as "bad"
(assuming we don't want to lose customers). We can use color to help as well
(blues/greens: good, reds: bad).

```{r manual_accounts_plot}
library(ggplot2)
library(dplyr, warn.conflicts = FALSE)
library(tidyr)

example_sales |>
  accounts_by_status(account_id, order_date, with_counts = TRUE, by = "quarter") |>
  select(period_start, starts_with("n_")) |>
  # negate the lost counts for visualization
  mutate(across(contains("lost"), ~ -.x)) |>
  # pivot to prepare for ggplot
  pivot_longer(starts_with("n_"), names_to = "status", values_to = "count") |>
  mutate(status = stringr::str_remove(status, "n_")) |>
  ggplot(aes(period_start, count, color = status)) +
  geom_line(linewidth = 1.2) +
  scale_color_manual(values = c(
    "active" = "#1f78b4",
    "new" = "#33a02c",
    "returning" = "#a6cee3",
    "temporarily_lost" = "#fb9a99",
    "terminally_lost" = "#e31a1c",
    "regained" = "#b2df8a",
    "cumulative" = "#999999"
  )) +
  theme_minimal()
```


`plot_accounts_by_status()` is a convenience function that does the above and a
bit more, cleaning up the legend, x-axis title, and if the last order_date is
before the end of the final time period (as in `example_sales`, which has no
orders after 2024-12-20), the final period will be shown with dashed lines to
indicate that the data may be incomplete.


```{r plot_accounts_1}
example_sales |>
  plot_accounts_by_status(account_id, order_date, by = "quarter")
```

You can suppress the dashed lines for incomplete periods with with
`force_final_period_complete = TRUE`, and exclude the cumulative line with
`include_cumulative = FALSE`.

```{r plot_accounts_2}
example_sales |>
  plot_accounts_by_status(
    account_id, order_date,
    by = "quarter",
    force_final_period_complete = TRUE,
    include_cumulative = FALSE
  )
```


## Business days in periodic intervals

`periodic_bizdays()` is a convenience wrapper around `bizdays::bizdays()`, that
calculates the number of business days in each periodic interval (e.g., monthly,
quarterly) between two dates, using calendars from RQuantLib for holiday
definitions.

```{r periodic_bizdays_example}
periodic_bizdays(
  from = "2025-01-01",
  to = "2025-12-31",
  by = "quarter",
  quantlib_calendars = c("UnitedStates", "UnitedKingdom")
)
```

## Year-to-date helpers

`mcrutils` provides a handful functions that can be helpful in creating
year-to-date analyses

Below we have 2.5 years of historical sales data ending on June 1, 2025.


```{r}
set.seed(123)
sales <- tibble(
  date = seq(
    from = as.Date("2023-01-01"),
    to = as.Date("2025-06-01"),
    by = "month"
  ),
  amount = rpois(30, lambda = 100)
)

head(sales)

```

`ytd_bounds()` gets the start and end of the year-to-date period for the latest
year in a vector of dates, 

```{r}
(bounds <- ytd_bounds(sales$date))
```

and `is_ytd_comparable()` is a logical vector that
indicates whether the dates in a vector are within a year-to-date period
relative to a given `end_date`.

So we can quickly filter the historical data to see how we're doing in
2025 compared to the same period (i.e. January - June) in 2023 and 2024:

```{r}
sales |>
  filter(is_ytd_comparable(date, max(bounds))) |>
  group_by(year = lubridate::year(date)) |>
  summarise(ytd_sales = sum(amount))
```

With `py_dates()` you can rollback a vector of dates to the same period in the
previous year, moving any fictitious dates to the prior valid day.

```{r}
c("2024-01-01", "2024-02-29", "2025-07-15") |>
  as.Date() |>
  py_dates()
```



# Visualization

## Auto-formatted datattables

`auto_dt()` uses `guess_col_fmts()` to determine the format of each column. You
can provide `pct_flags` and `curr_flags` (character vectors) if you need to
control the list of "signal" words that indicate a column is a percentage or
currency.

You can suppress the buttons for copy, csv, and excel downloads with `buttons =
FALSE`.


```{r guess_col_fmts_example, screenshot.opts=list(vwidth= 800, vheight = 600), message=FALSE}
tribble(
  ~product, ~weight, ~dollaz_earned, ~growth_pct,
  "Widget A", 13.53, 1023.21, 0.051,
  "Widget B", 22.61, 150.24, 0.103,
  "Widget C", 40.54, 502.26, 0.021,
  "Widget D", 34.21, 2000.95, 0.154
) |>
  mutate(product = as.factor(product)) |>
  auto_dt(numeric_digits = 1, pct_digits = 0, curr_flags = c("revenue", "dollaz"))
```



## Quarterly breaks and labels

`scales::label_date_short()` is a great function for labeling dates in `ggplot2`,
but unfortunately it can't support quarterly breaks and labels out of the box.

`mcrutils` provides a set of functions to create quarterly breaks and labels for
date scales in `ggplot2`. The `breaks_quarters()` function generates breaks for
quarters, and `label_quarters_short()` generates minimal labels for these breaks
in a two-line format (like `scales::label_date_short()`), labeling every
quarter, but only including the year when it changes from the previous label.


```{r automatic-quarterly-breaks}
library(ggplot2)

economics |>
  filter(date >= "2005-05-01", date <= "2007-03-01") |>
  ggplot(aes(date, pce)) +
  geom_line() +
  scale_x_date(
    breaks = breaks_quarters(),
    labels = label_quarters_short()
  ) +
  labs(
    title = "Automatic Quarterly Breaks",
    subtitle = "with concise labels"
  ) +
  theme(panel.grid.minor.x = element_blank())
```



The automatic version of `breaks_quarters()` tries to return a reasonable number of breaks over a wide range of dates, down-sampling to semesters and years as needed.

```{r semester-breaks}
economics |>
  filter(date >= "2005-05-01", date <= "2009-03-01") |>
  ggplot(aes(date, pce)) +
  geom_line() +
  scale_x_date(
    breaks = breaks_quarters(),
    labels = label_quarters_short()
  ) +
  labs(
    title = "Switching to semesters for longer ranges",
    subtitle = "always labelling Q1/Q3, never Q2/Q4"
  ) +
  theme(panel.grid.minor.x = element_blank())
```

```{r yearly-breaks-for-long-ranges}
economics |>
  filter(date >= "2000-05-01", date <= "2010-03-01") |>
  ggplot(aes(date, pce)) +
  geom_line() +
  scale_x_date(
    breaks = breaks_quarters(),
    labels = label_quarters_short()
  ) +
  labs(
    title = "Switching to yearly for very long ranges",
    subtitle = "rather silly"
  ) +
  theme(panel.grid.minor.x = element_blank())
```

With very long date ranges like this, you are likely better off switching from
these quarterly functions to the more standard date breaks and labels in
`ggplot2`.


You can force a fixed break width if quarters are desired regardless of the date range.

```{r fixed-quarterly-breaks}
example_sales |>
  plot_accounts_by_status(account_id, order_date, by = "quarter") +
  scale_x_date(
    breaks = breaks_quarters(width = "1 quarter"),
    labels = label_quarters_short()
  ) +
  theme(panel.grid.minor.x = element_blank())
```


